<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Design for autonomous execution: treat your product as a pipeline that agents can operate end-to-end. Principles, patterns, and a small blueprint for one-person companies."
    />
    <title>The product is the pipeline | Subtle</title>
    <link rel="icon" href="public/favicon.ico" type="image/x-icon" />
    <link
      rel="canonical"
      href="https://subtle.so/the-product-is-the-pipeline.html"
    />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://subtle.so/the-product-is-the-pipeline.html"
    />
    <meta property="og:title" content="The product is the pipeline | Subtle" />
    <meta
      property="og:description"
      content="Design for autonomous execution: treat your product as a pipeline that agents can operate end-to-end. Principles, patterns, and a small blueprint for one-person companies."
    />
    <meta
      property="og:image"
      content="https://subtle.so/public/subtle-tree.jpg"
    />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta
      property="twitter:url"
      content="https://subtle.so/the-product-is-the-pipeline.html"
    />
    <meta
      property="twitter:title"
      content="The product is the pipeline | Subtle"
    />
    <meta
      property="twitter:description"
      content="Design for autonomous execution: treat your product as a pipeline that agents can operate end-to-end. Principles, patterns, and a small blueprint for one-person companies."
    />
    <meta
      property="twitter:image"
      content="https://subtle.so/public/subtle-tree.jpg"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles/main.css" />
    <script src="styles/tailwind.js"></script>
    <script src="scripts/darkMode.js"></script>
    <script src="scripts/toast.js"></script>
    <script src="scripts/components.js"></script>
    <script src="scripts/keyboard-shortcuts.js"></script>
    <script
      defer
      data-domain="subtle.so"
      src="https://plausible.io/js/script.js"
    ></script>
  </head>
  <body
    class="min-h-screen noise bg-dark-deeper transition-colors duration-100 relative"
  >
    <div id="toast" class="toast"></div>
    <div class="min-h-screen flex flex-col">
      <!-- Include header -->
      <div include-html="components/header.html"></div>

      <div
        class="w-full max-w-2xl mx-auto sm:border-x border-gray-600 border-dashed flex-1 flex flex-col items-center justify-start"
      >
        <!-- Article content -->
        <article
          class="w-full border-b border-gray-600 border-dashed p-6 pb-2 text-dark-text transition-colors duration-200"
        >
          <div class="w-full max-w-2xl pb-2">
            <div class="flex items-center justify-between gap-4 mb-4">
              <div class="flex flex-col items-start">
                <div class="text-xs opacity-75 mb-1 select-none">
                  August 19, 2025
                </div>
                <h1 class="font-bold">The product is the pipeline</h1>
              </div>
              <button
                onclick="copyToClipboard(window.location.href)"
                class="text-sm px-2 py-1 rounded-lg bg-dark-surface border border-gray-600 hover:border-gray-400 transition-colors select-none"
              >
                Copy link
              </button>
            </div>
            <div class="prose prose-invert">
              <!-- Content goes here -->
              <p>
                The best AI-native products are not <i>apps</i>. They're
                <b>pipelines</b> that turn intent into outcomes with minimal
                ceremony. Agents (and humans) enter on one end with a goal,
                observable work happens in the middle, and value pops out the
                other side—reliably, reversibly, and on schedule.
              </p>
              <p>
                If you're a one-person company, thinking in pipelines compounds
                leverage. Pipelines make work <i>addressable</i> (each step has
                a contract), <i>measurable</i> (you can see what's slow or
                flaky), and <i>automatable</i> (agents can operate steps without
                human glue).
              </p>

              <h3>Why pipelines beat apps</h3>
              <ul class="list-disc pl-6 mb-4">
                <li>
                  <b>Determinism over vibes</b>: steps have explicit inputs and
                  outputs.
                </li>
                <li>
                  <b>Observability</b>: logs, traces, and metrics tie to stages,
                  not pages.
                </li>
                <li>
                  <b>Composability</b>: swap a step (model, tool, scraper)
                  without redesigning UI.
                </li>
                <li>
                  <b>Parallelism</b>: fan-out work safely; agents don't block
                  each other.
                </li>
                <li>
                  <b>Recoverability</b>: failed stages re-run from checkpoints,
                  not from scratch.
                </li>
              </ul>

              <h3>Design principles</h3>
              <ul class="list-disc pl-6 mb-4">
                <li>
                  <b>Contracts first</b>: define a schema for every step's
                  inputs/outputs. Treat prompts and tools like APIs. Version
                  them.
                </li>
                <li>
                  <b>Idempotent by default</b>: safe to retry any step. Use
                  content-based keys and write-once stores.
                </li>
                <li>
                  <b>Observable everything</b>: structured logs with correlation
                  IDs, stage timings, token spend, and failure reasons.
                </li>
                <li>
                  <b>Human checkpoints where it matters</b>: review gates on
                  irreversible steps (send, publish, charge). Everything else is
                  fully agentic.
                </li>
                <li>
                  <b>Reversible writes</b>: prefer append-only, soft-deletes,
                  and delayed commits. Agents make fewer messes when they can
                  undo.
                </li>
              </ul>

              <h3>A small blueprint</h3>
              <ol class="list-decimal pl-6 mb-4">
                <li>
                  <b>Define the job</b>: a single sentence that starts with a
                  verb and ends with a deliverable. Example: “Summarize 50 URLs
                  into a daily brief.”
                </li>
                <li>
                  <b>Model the stages</b>: fetch → clean → enrich → generate →
                  score → ship. Write JSON schemas for each boundary.
                </li>
                <li>
                  <b>Assign workers</b>: a lightweight worker per stage
                  (function, queue consumer, or cron). Keep them stateless.
                </li>
                <li>
                  <b>Add guardrails</b>: evals on critical steps, schema
                  validation, and cost/time budgets per job.
                </li>
                <li>
                  <b>Instrument</b>: emit events with <code>jobId</code>,
                  <code>stage</code>, <code>ms</code>, <code>tokens</code>, and
                  <code>status</code>. Plot p95 per stage weekly.
                </li>
              </ol>

              <h3>Anti-patterns to avoid</h3>
              <ul class="list-disc pl-6 mb-4">
                <li>
                  <b>Prompt spaghetti</b>: dozens of ad-hoc prompts with
                  implicit contracts. Centralize prompts with owners and tests.
                </li>
                <li>
                  <b>Stateful agents</b>: long-running, memory-heavy loops that
                  are hard to resume. Prefer short-lived, retryable steps with
                  job context.
                </li>
                <li>
                  <b>UI-first thinking</b>: build the pipeline and metrics
                  before UI polish. Pretty dashboards won’t fix flaky execution.
                </li>
              </ul>

              <h3>Metrics that matter</h3>
              <ul class="list-disc pl-6 mb-4">
                <li>
                  <b>Time to first output</b>: request → first usable artifact.
                </li>
                <li>
                  <b>Stage p95</b>: slowest 5% by stage expose bottlenecks and
                  flaky tools.
                </li>
                <li>
                  <b>Recovery rate</b>: % of failed jobs that succeed on
                  automatic retry.
                </li>
                <li>
                  <b>Human approvals per 100 jobs</b>: drive this toward zero
                  for non-risky flows.
                </li>
              </ul>

              <p>
                When the product is the pipeline, scope becomes legible,
                progress is measurable, and agents become teammates who do real
                work—not demos. If you're building a one-person company, this is
                how you get compound leverage.
              </p>
            </div>
          </div>
        </article>
        <div include-html="components/intro-box.html"></div>
      </div>
      <div include-html="components/footer.html"></div>
    </div>
  </body>
</html>
